#summary How to add more queries.

== Introduction ==

Here we are going to cover adding your own statement to Rocksteady.  EPL(Esper Processing Language) is a language used in [http://esper.codehaus.org/ Esper], Rocksteady's choice of complex event processing engine.  EPL looks similar to SQL with "select", "from", or "where" in its syntax, the biggest difference between EPL and SQL is the data source.  In SQL, query is ran against data already stored in a database.  In EPL, query is ran against data as they arrive.

Case in point:

*SELECT `*` FROM metrics WHERE value > 80*

||SQL||Return all rows from a table named "metrics" where a field named "value" has a value larger than 80.  Data is in database.||
||EPL||Whenever new data arrive, query is executed and it will return all POJO(plain old java object) that has attribute named "value" larger than 80||

This, is how CEP process data in real time.  Because EPL processes  data as they come in, there are a few additional language feature that's applicable to EPL such as setting time window of the data.

== Details ==

When metrics come from application into MQ, Rocksteady consumes and parses the metrics into POJO(plain old java object) which is then feed into Esper CEP engine.  Esper will then run all the statements against this new pojo and what comes out depend on the statement.  It could be an aggregation statement which just add the value to existing value, or it could be a threshold statement which might trigger an email or Nagios alert or it could be a correlation statement which needs further processing by other statement.

Assuming we are using [MetricFormat default metric convention],

{{{retention.app_name.component+.colo.hostname value unix_timestamp}}}

these are the field name that's available to use in query.:

{{{
  private String original;
  private String retention = "";
  private String app = "";
  private String name;
  private String colo = "";
  private String hostname = "";
  private Double value;
  private Double timestamp;
}}}

So for metric string

{{{1min.juicer.system.cpu.prct_idle.dc1.pi101 82 1283192317}}}

||original||`1min.juicer.system.cpu.prct_idle.dc1.pi101 82 1283192317`||
||retention||1min||
||app||juicer||
||name||system.cpu.prct_idle||
||colo||dc1||
||hostname||pi101||
||value||82||
||timestamp||1283192317||

A statement could look something like this: (From [http://rocksteady.googlecode.com/svn/trunk/src/main/resources/META-INF/spring/eplStatements.xml eplStatement.xml])

{{{
  <bean class="com.admob.rocksteady.router.cep.StatementBean" id="metricAveraged">
  <constructor-arg value="SELECT name, colo, avg(value)  as value, retention, app
                          FROM Metric(app='admixer' or app='ustore').std:groupby(colo,name,app).win:time_batch(${cepTimeBatchEverest} sec)
                          GROUP BY name, colo, retention, app                                                                                                  
                          "/>
    <property name="listeners">
     <list>
       <bean class="com.admob.rocksteady.reactor.Graphite">
           <property name="suffix" value="averaged"/>
       </bean>    
     </list>
    </property>
  </bean>
}}}

For none Java folks, bean is like little piece of code that can be used later in other places.  Instead of coding actual Java, you can see from the statement above, we initiate a new com.admob.rocksteady.router.cep.StatementBean class with value in constructor-arg, gave it an 'ID', then set one of its property "listeners" with another bean.

The id "metricAveraged" is then used in [http://rocksteady.googlecode.com/svn/trunk/src/main/resources/META-INF/spring/epl.xml epl.xml] to tell Esper what statements to load.
 
For detail documentation on EPL, please refer to [http://esper.codehaus.org/esper/documentation/documentation.html Esper documentation].

Let's look at what this statement does:
{{{
SELECT name, colo, avg(value)  as value, retention, app
FROM Metric(app='admixer' or app='ustore').std:groupby(colo,name,app).win:time_batch(${cepTimeBatchEverest} sec)
GROUP BY name, colo, retention, app  
}}}

This EPL look for metrics with app name equal to 'admixer' or 'ustore', then group them by colo, name, and app and set a time window of ${cepTimeBatchEverest} seconds for each unique group by.  Then at output time, we have another GROUP BY so rows in time batch window is output once and used aggregate function avg() to calculate average value of this metric name per colo and app.